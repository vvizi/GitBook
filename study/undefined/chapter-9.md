---
description: 2024.03.06
---

# Chapter 9

### **Summary**

#### <mark style="background-color:red;">9. 설계의 건전성을 해치는 여러 악마</mark>

`요약 : 설계에`` `**`Best`**`는 없다. 항상`` `**`Better`**`를 목표로 할 뿐`

**\[데드 코드(dead cpde)] :** 도달 불가능한 코드(unreachable code)

절대로 실행되지 않는 조건 내부에 있는 코드로 발견 즉시 제거해야 한다.

**\[YAGNI 원칙 (You Aren't Gonna Need It)]**

지금 필요한 기능을 최대한 간단한 형태로 만드는 것이 가독성과 유지 보수성을 높인다.

**\[매직 넘버 (의미를 알기 힘든 숫자)]**

설명이 없는 숫자는 개발자를 혼란스럽게 만들기 때문에, 상수 활용을 권장한다.

**\[하나의 String 변수에 여러 값 저장하는 형태]**

`split()` 메서드 등 추가적인 작업이 필요하다. → 의미가 다른 값은 각각 다른 변수에 저장하는 것이 좋다

**\[전역 변수]** 여러 로직에서 참조하고 값을 변경하면, 어디에서 어떤 시점을 변경했는지 파악하기 힘들다. → 영향 범위가 적을수록 로직을 이해하고 구현하기 쉽다.

**\[null 문제]** null을 리턴 / 전달하지 않는 설계 하기

**\[예외를 catch 하고 무시하는 코드]** try catch에 catch 문에 별다를 처리를 하지 않는 코드. → 최소한의 로그로 기록해야한다.

**\[메타 프로그래밍]**

프로그램 실행 중에 해당 프로그램 구조 자체를 제어하는 프로그래밍 → 리플렉션 API로 `readonly`를 제어하면 안된다.

**\[기술 중심 패키징]** 구조에 따라 폴더와 패키지를 나누는 것을 기술 중심 패키징에 따라 폴더를 구분하면, 관련성을 알기 어려워진다. → 비즈니스 개념대로 폴더를 구분하자



### **Discussion Points**

Q. 여러 로직에서 전역 변수를 참조하고 값을 변경하면, 어디에서 어떤 시점에 값을 변경했는지 파악하기 대단히 힘듭니다.

* **전역** 상태 관리 라이브러리
  * 이벤트 발생에 따른 Mobx 데이터의 변경 흐름을 따라가기 어려워 최적화에 어려움을 겪은 적이 있음
* 그렇다면 프론트엔드에서 어떤 방법으로 변수를 관리하는 방법이 좋을까?

A.&#x20;

* `Context API` : 컴포넌트 트리에 상태를공유하기 위해 사용
* `useState` : 개별 컴포넌트 내에서 간단한 상태 관리
* 상태 관리 라이브러리 : 전역 상태가 많거나 복잡한 로직을 관리



### **Apply**

* Dropdown, Dialog 등 복잡한 컴포넌트 트리를 가지는 컴포넌트에 Context API 적용



### Retrospective

* YAGNI 원칙에 따라 필요한 기능에만 집중하기.&#x20;
* 전역 변수 사용을 줄이고 Context API와 상태 관리 라이브러리를 적절히 활용하는 것이 중요!
